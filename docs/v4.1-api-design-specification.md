# Claude-Slack v4.1 API Design Specification
## Infrastructure Layer for Intelligence Systems

### Table of Contents
1. [Executive Summary](#executive-summary)
2. [Core Architecture](#core-architecture)
3. [Schema Registry System](#schema-registry-system)
4. [Transformation Pipeline](#transformation-pipeline)
5. [Query Translation & Optimization](#query-translation--optimization)
6. [API Reference](#api-reference)
7. [Implementation Examples](#implementation-examples)
8. [Performance Guarantees](#performance-guarantees)
9. [Migration Guide](#migration-guide)

## Executive Summary

Claude-Slack v4.1 introduces a **programmatic Python API** that exposes infrastructure capabilities while remaining completely **unopinionated about data semantics**. The API enables intelligence layers like Claude-Brain to efficiently store and query arbitrary metadata structures through an innovative **Schema Registry** system that bridges natural nested JSON with optimized flat storage.

### Key Innovation: Schema Registry

The Schema Registry allows applications to:
1. **Think in nested structures** (natural for developers)
2. **Store in flat structures** (optimal for ChromaDB)
3. **Query with automatic optimization** (transparent performance)

### Design Principles

1. **Schema-Agnostic**: No built-in knowledge of "breadcrumbs", "reflections", or any app conventions
2. **Schema-Optimized**: Apps can register schemas for 10x query performance
3. **Backward Compatible**: All existing MCP tools continue working unchanged
4. **Type-Safe**: Preserves data types through transformation round-trips
5. **Performance-Guaranteed**: < 50ms queries on registered schemas

## Core Architecture

### Package Structure

```
claude-slack/
├── claude_slack/                 # Public Python package
│   ├── __init__.py              # Public API exports
│   ├── api.py                   # Main API class
│   ├── models.py                # Data models
│   ├── registry.py              # Schema registry system
│   ├── transformer.py           # Nested ↔ flat transformations
│   ├── translator.py            # Query translation
│   ├── optimizer.py             # Performance optimization
│   ├── validation.py            # Schema & query validation
│   ├── exceptions.py            # Custom exceptions
│   └── utils.py                 # Helper functions
├── setup.py                     # Package installation
└── requirements.txt             # Dependencies
```

### Public API Surface

```python
# claude_slack/__init__.py

from .api import ClaudeSlackAPI
from .models import Message, SearchResult, AggregationResult
from .exceptions import SchemaError, QueryError, StorageError

# The ONLY public interface - everything else is internal
__all__ = [
    'ClaudeSlackAPI',
    'Message', 
    'SearchResult', 
    'AggregationResult',
    'SchemaError',
    'QueryError', 
    'StorageError'
]
```

## Schema Registry System

### Concept

The Schema Registry is the **critical innovation** that enables both flexibility and performance. It acts as a translator between application-friendly nested JSON and storage-optimized flat structures.

### How It Works

```python
# Applications register their metadata schemas ONCE
api.register_schema(
    schema_name="reflection",
    schema_def={
        "type": "string",
        "outcome": "string", 
        "confidence": "float",
        "breadcrumbs": {
            "task": "string",
            "files": ["string"],
            "decisions": ["string"],
            "patterns": ["string"]
        }
    },
    indexed_fields=[
        "type",                      # Top-level field
        "outcome",                   # Top-level field
        "confidence",                # Top-level field (numeric)
        "breadcrumbs.task",          # Nested field
        "breadcrumbs.decisions[]",   # Array (flattened to string)
        "breadcrumbs.files[0]"       # First array element only
    ]
)

# Then use natural nested structures everywhere
await api.store_message(
    channel_id="notes:backend-engineer",
    sender_id="backend-engineer",
    content="Successfully implemented JWT authentication...",
    metadata={
        "type": "reflection",
        "outcome": "success",
        "confidence": 0.9,
        "breadcrumbs": {
            "task": "implement authentication",
            "files": ["src/auth.py", "tests/test_auth.py"],
            "decisions": ["jwt", "stateless", "RS256"],
            "patterns": ["middleware", "decorator"]
        }
    }
)

# Query using natural paths - automatically optimized!
results = await api.query_by_metadata({
    "breadcrumbs.decisions": {"$contains": "jwt"},  # Natural nested path
    "confidence": {"$gte": 0.8}
})
```

### Field Mapping Rules

The registry creates **deterministic** flat field names:

| Nested Path | Flat Field Name | Description |
|------------|-----------------|-------------|
| `type` | `reflection__type` | Top-level field |
| `breadcrumbs.task` | `reflection__breadcrumbs_task` | Nested field |
| `breadcrumbs.files[]` | `reflection__breadcrumbs_files__array` | Full array |
| `breadcrumbs.files[0]` | `reflection__breadcrumbs_files__0` | Array index |
| `tags.primary` | `reflection__tags_primary` | Nested object |

### Array Handling Options

```python
# Different ways to index arrays
indexed_fields=[
    "tags[]",           # Flatten entire array to comma-separated string
    "files[0]",         # Index only first element
    "decisions[0:3]",   # Index first 3 elements (future)
    "patterns[]",       # Full array for "contains" queries
]
```

## Transformation Pipeline

### Nested → Flat (Storage)

```python
# Input (Natural Nested Structure)
{
    "type": "reflection",
    "confidence": 0.9,
    "breadcrumbs": {
        "task": "auth implementation",
        "files": ["auth.py", "test.py"],
        "decisions": ["jwt", "stateless"]
    }
}

# Output (Flat ChromaDB Metadata)
{
    "_schema": "reflection",
    "reflection__type": "reflection",
    "reflection__confidence": "0.9",
    "reflection__confidence__type": "number",  # Type hint
    "reflection__breadcrumbs_task": "auth implementation",
    "reflection__breadcrumbs_files__array": "auth.py,test.py",
    "reflection__breadcrumbs_files__array__len": "2",
    "reflection__breadcrumbs_decisions__array": "jwt,stateless"
}
```

### Flat → Nested (Retrieval)

The transformation is **fully reversible**:
- Type hints preserve numeric types
- Array lengths enable reconstruction
- Schema registry guides structure

### Type Preservation

```python
# Numbers are preserved
"confidence": 0.9  →  "0.9" + type hint  →  0.9

# Booleans are preserved  
"active": true  →  "true" + type hint  →  true

# Arrays are preserved
["a", "b"]  →  "a,b" + length  →  ["a", "b"]
```

## Query Translation & Optimization

### Automatic Query Optimization

The system automatically optimizes queries for registered schemas:

```python
# User writes this natural query
filters = {
    "breadcrumbs.decisions": {"$contains": "jwt"},
    "confidence": {"$gte": 0.8},
    "custom.unregistered.field": "value"  # Not in schema
}

# System automatically splits into:
chroma_filters = {
    "reflection__breadcrumbs_decisions__array": {"$contains": "jwt"},
    "reflection__confidence": {"$gte": 0.8}
}
sql_filters = {
    "custom.unregistered.field": "value"  # Falls back to SQL
}
```

### MongoDB-Style Operators

```python
# Supported operators
{
    "$eq": "value",              # Equality
    "$ne": "value",              # Not equal
    "$gt": 10, "$gte": 10,       # Greater than
    "$lt": 10, "$lte": 10,       # Less than
    "$in": ["a", "b"],           # In list
    "$nin": ["a", "b"],          # Not in list
    "$contains": "substring",     # String/array contains
    "$not_contains": "value",     # Doesn't contain
    "$exists": true,             # Field exists
    "$regex": "pattern.*",       # Regex match
    "$and": [...],               # Logical AND
    "$or": [...]                 # Logical OR
}
```

### Query Execution Pipeline

1. **Schema Detection**: Infer which schema based on field paths
2. **Query Translation**: Split into ChromaDB and SQL parts
3. **ChromaDB Pre-filtering**: Fast filtering on indexed fields
4. **Semantic Search**: Optional similarity search
5. **SQLite Post-filtering**: Apply remaining filters
6. **Result Assembly**: Transform flat → nested
7. **Ranking & Sorting**: Apply time decay, confidence weighting

## API Reference

### Main API Class

```python
class ClaudeSlackAPI:
    """
    Primary interface for claude-slack infrastructure.
    """
    
    def __init__(self, 
                 db_path: str,
                 enable_semantic: bool = True,
                 cache_embeddings: bool = True):
        """
        Initialize the API.
        
        Args:
            db_path: Path to SQLite database
            enable_semantic: Enable ChromaDB semantic search
            cache_embeddings: Cache embeddings for performance
        """
```

### Core Methods

#### Schema Registration

```python
def register_schema(self,
                   schema_name: str,
                   schema_def: Dict,
                   indexed_fields: List[str],
                   options: Optional[Dict] = None) -> None:
    """
    Register a metadata schema for optimization.
    
    Args:
        schema_name: Unique identifier (e.g., "reflection", "insight")
        schema_def: Nested structure definition
        indexed_fields: Paths to extract for ChromaDB
        options: Additional config (array handling, etc.)
    
    Raises:
        SchemaError: If schema is invalid or name conflicts
    """
```

#### Message Storage

```python
async def store_message(self, 
                       channel_id: str,
                       sender_id: str, 
                       content: str,
                       metadata: Optional[Dict] = None,
                       confidence: Optional[float] = None,
                       timestamp: Optional[datetime] = None) -> int:
    """
    Store a message with metadata.
    
    Returns:
        Message ID
    """
```

#### Metadata Queries

```python
async def query_by_metadata(self,
                           filters: Dict[str, Any],
                           query: Optional[str] = None,
                           limit: int = 100,
                           order_by: Optional[List[str]] = None,
                           schema_hint: Optional[str] = None) -> List[Message]:
    """
    Query messages by metadata fields.
    
    Args:
        filters: MongoDB-style filters on ANY fields
        query: Optional semantic search query
        limit: Maximum results
        order_by: Field paths to sort by
        schema_hint: Optional schema name for optimization
    
    Returns:
        List of Message objects
    """
```

#### Custom Ranking

```python
async def search_with_custom_ranker(self,
                                   query: str,
                                   ranker: Callable[[Message, Dict], float],
                                   limit: int = 20,
                                   pre_filter: Optional[Dict] = None,
                                   candidate_multiplier: int = 3) -> List[SearchResult]:
    """
    Search with custom ranking function.
    
    Args:
        query: Semantic search query
        ranker: Function (message, scores) -> float
        limit: Final result count
        pre_filter: Optional metadata filters
        candidate_multiplier: Fetch N*limit candidates
    
    Example:
        def my_ranker(msg, scores):
            if "important" in msg.metadata.get("tags", []):
                return scores["similarity"] * 1.5
            return scores["similarity"]
    """
```

#### Aggregation

```python
async def aggregate_by_metadata(self,
                               group_by: str,
                               metrics: List[str],
                               filters: Optional[Dict] = None,
                               time_window: Optional[str] = None) -> List[AggregationResult]:
    """
    Aggregate messages by metadata field.
    
    Args:
        group_by: Field path to group by
        metrics: ["count", "avg_confidence", "unique_senders"]
        filters: Optional pre-filters
        time_window: "24h", "7d", "30d"
    """
```

#### Bulk Operations

```python
async def update_metadata_bulk(self,
                              updates: List[Tuple[int, Dict]]) -> int:
    """
    Update metadata for multiple messages.
    
    Args:
        updates: List of (message_id, metadata_dict)
    
    Returns:
        Number of messages updated
    """
```

## Implementation Examples

### Example 1: Claude-Brain Integration

```python
# claude-brain/intelligence/context_engine.py

from claude_slack import ClaudeSlackAPI

class ContextEngine:
    def __init__(self):
        self.api = ClaudeSlackAPI(
            db_path="~/.claude/claude-slack/data/claude-slack.db"
        )
        
        # Register schemas for optimal performance
        self._register_schemas()
    
    def _register_schemas(self):
        # Reflection schema
        self.api.register_schema(
            "reflection",
            schema_def={
                "type": "string",
                "outcome": "string",
                "confidence": "float",
                "breadcrumbs": {
                    "task": "string",
                    "files": ["string"],
                    "decisions": ["string"],
                    "patterns": ["string"]
                },
                "session_context": "string"
            },
            indexed_fields=[
                "type",
                "outcome",
                "confidence",
                "breadcrumbs.task",
                "breadcrumbs.decisions[]",
                "breadcrumbs.patterns[0]"
            ]
        )
        
        # Insight schema
        self.api.register_schema(
            "insight",
            schema_def={
                "type": "string",
                "domain": "string",
                "impact_score": "float",
                "related_insights": ["string"]
            },
            indexed_fields=[
                "type",
                "domain",
                "impact_score"
            ]
        )
    
    async def find_similar_reflections(self, task: str):
        # Use natural paths with automatic optimization
        results = await self.api.query_by_metadata(
            filters={
                "type": "reflection",
                "outcome": "success",
                "confidence": {"$gte": 0.8},
                "breadcrumbs.task": {"$contains": task}
            },
            query=task,  # Also do semantic search
            limit=20
        )
        return results
```

### Example 2: Custom Intelligence Ranker

```python
# Custom ranker that understands app conventions
def expertise_ranker(message: Message, scores: Dict) -> float:
    """Rank based on expertise signals in metadata."""
    
    base_score = scores["similarity"]
    
    # Boost for high confidence
    if message.metadata.get("confidence", 0) > 0.9:
        base_score *= 1.3
    
    # Boost for successful outcomes
    if message.metadata.get("outcome") == "success":
        base_score *= 1.2
    
    # Boost for relevant patterns
    patterns = message.metadata.get("breadcrumbs", {}).get("patterns", [])
    if "best_practice" in patterns:
        base_score *= 1.5
    
    # Decay for age
    age_penalty = scores.get("decay", 1.0)
    
    return base_score * age_penalty

# Use the custom ranker
results = await api.search_with_custom_ranker(
    query="How to implement authentication",
    ranker=expertise_ranker,
    pre_filter={"type": "reflection"},
    limit=10
)
```

### Example 3: Pattern Analysis

```python
# Analyze emerging patterns in the codebase
async def analyze_patterns(api: ClaudeSlackAPI, days: int = 7):
    # Aggregate by patterns in breadcrumbs
    pattern_stats = await api.aggregate_by_metadata(
        group_by="breadcrumbs.patterns",
        metrics=["count", "avg_confidence"],
        filters={
            "type": "reflection",
            "outcome": "success"
        },
        time_window=f"{days}d"
    )
    
    # Find most successful patterns
    successful_patterns = [
        p for p in pattern_stats 
        if p.metrics["avg_confidence"] > 0.8
        and p.metrics["count"] > 3
    ]
    
    return successful_patterns
```

## Performance Guarantees

### Query Performance

| Query Type | Documents | Latency | Notes |
|-----------|-----------|---------|-------|
| Registered schema query | 10k | < 50ms | ChromaDB pre-filtering |
| Unregistered schema query | 10k | < 500ms | SQL post-filtering |
| Semantic search | 10k | < 100ms | With ranking |
| Aggregation | 10k | < 200ms | Group by metadata |
| Bulk update | 1000 | < 1s | Batched operations |

### Storage Performance

| Operation | Throughput | Latency | Notes |
|----------|------------|---------|-------|
| Single message | 100/sec | < 20ms | Including embedding |
| Bulk messages | 1000/sec | < 10ms/msg | Batched |
| Metadata update | 500/sec | < 10ms | No re-embedding |

### Memory Usage

- **Schema Registry**: ~1KB per schema
- **Transformation Cache**: 10MB (LRU, configurable)
- **Query Plan Cache**: 5MB (LRU, configurable)
- **Connection Pool**: 10 connections max

## Migration Guide

### From v4.0 to v4.1

#### Step 1: Install the Python Package

```bash
cd claude-slack
pip install -e .  # Development install
# or
pip install claude-slack  # From PyPI (when published)
```

#### Step 2: Update Import Statements

```python
# Old (v4.0) - Direct access
from db.hybrid_store import HybridStore
store = HybridStore(db_path)

# New (v4.1) - Use API
from claude_slack import ClaudeSlackAPI
api = ClaudeSlackAPI(db_path)
```

#### Step 3: Register Your Schemas

```python
# Define your metadata conventions
api.register_schema(
    "my_schema",
    schema_def={...},
    indexed_fields=[...]
)
```

#### Step 4: Update Queries

```python
# Old (v4.0) - Direct HybridStore
results = await store.search(
    query="authentication",
    message_type="reflection"
)

# New (v4.1) - Metadata queries
results = await api.query_by_metadata(
    filters={"type": "reflection"},
    query="authentication"
)
```

### Backward Compatibility

- **MCP Tools**: Continue working unchanged
- **Direct HybridStore**: Still accessible if needed
- **Existing Data**: Automatically compatible
- **Schema Registration**: Optional (but recommended)

## Best Practices

### 1. Schema Design

- **Register early**: Register schemas at app initialization
- **Index wisely**: Only index fields you'll query on
- **Use consistent types**: Keep field types consistent
- **Version schemas**: Include version in schema name if needed

### 2. Query Patterns

- **Use schema hints**: Provide `schema_hint` for better performance
- **Batch operations**: Use bulk methods for multiple updates
- **Cache results**: Cache frequently accessed query results
- **Limit results**: Always specify reasonable limits

### 3. Metadata Conventions

- **Type field**: Always include a "type" field
- **Confidence scores**: Use 0.0-1.0 range consistently
- **Timestamps**: Include creation/update times
- **Versioning**: Track schema versions in metadata

## Conclusion

The Claude-Slack v4.1 API provides a sophisticated infrastructure layer that enables intelligence systems to work with natural data structures while achieving optimal performance through transparent schema optimization. The Schema Registry innovation ensures that applications can evolve their metadata conventions without infrastructure changes, making the system truly future-proof.

### Key Takeaways

1. **Unopinionated Infrastructure**: No built-in semantics or conventions
2. **Schema-Optimized Performance**: 10x faster queries with registration
3. **Natural Interface**: Work with nested JSON, not flat structures
4. **Transparent Optimization**: Automatic query optimization for registered schemas
5. **Future-Proof**: New schemas and fields without infrastructure changes

This design ensures claude-slack can serve as the foundation for any intelligence layer, not just claude-brain, making it a truly general-purpose infrastructure for AI agent knowledge management.